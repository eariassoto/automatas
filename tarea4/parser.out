Created by PLY version 3.6 (http://www.dabeaz.com/ply)

Unused terminals:

    SUB
    CMP
    XOR
    ADD
    AND
    NAME
    NOOP
    NOT
    OR

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     expression -> cod1 R NUMBER [ NUMBER ]
Rule 3     cod1 -> LOAD
Rule 4     cod1 -> STORE
Rule 5     expression -> cod2 R NUMBER NUMBER
Rule 6     cod2 -> LOADI
Rule 7     cod2 -> SHIFT
Rule 8     expression -> STOREI NUMBER [ NUMBER ]
Rule 9     expression -> cod4 [ NUMBER ]
Rule 10    cod4 -> JMP
Rule 11    cod4 -> BB
Rule 12    cod4 -> BEQ

Terminals, with rules where they appear

ADD                  : 
AND                  : 
BB                   : 11
BEQ                  : 12
CMP                  : 
JMP                  : 10
LOAD                 : 3
LOADI                : 6
NAME                 : 
NOOP                 : 
NOT                  : 
NUMBER               : 2 2 5 5 8 8 9
OR                   : 
R                    : 2 5
SHIFT                : 7
STORE                : 4
STOREI               : 8
SUB                  : 
XOR                  : 
[                    : 2 8 9
]                    : 2 8 9
error                : 

Nonterminals, with rules where they appear

cod1                 : 2
cod2                 : 5
cod4                 : 9
expression           : 1
statement            : 0

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) expression -> . cod1 R NUMBER [ NUMBER ]
    (5) expression -> . cod2 R NUMBER NUMBER
    (8) expression -> . STOREI NUMBER [ NUMBER ]
    (9) expression -> . cod4 [ NUMBER ]
    (3) cod1 -> . LOAD
    (4) cod1 -> . STORE
    (6) cod2 -> . LOADI
    (7) cod2 -> . SHIFT
    (10) cod4 -> . JMP
    (11) cod4 -> . BB
    (12) cod4 -> . BEQ

    STOREI          shift and go to state 13
    LOAD            shift and go to state 1
    STORE           shift and go to state 8
    LOADI           shift and go to state 2
    SHIFT           shift and go to state 5
    JMP             shift and go to state 4
    BB              shift and go to state 3
    BEQ             shift and go to state 11

    cod2                           shift and go to state 7
    cod4                           shift and go to state 6
    expression                     shift and go to state 12
    statement                      shift and go to state 9
    cod1                           shift and go to state 10

state 1

    (3) cod1 -> LOAD .

    R               reduce using rule 3 (cod1 -> LOAD .)


state 2

    (6) cod2 -> LOADI .

    R               reduce using rule 6 (cod2 -> LOADI .)


state 3

    (11) cod4 -> BB .

    [               reduce using rule 11 (cod4 -> BB .)


state 4

    (10) cod4 -> JMP .

    [               reduce using rule 10 (cod4 -> JMP .)


state 5

    (7) cod2 -> SHIFT .

    R               reduce using rule 7 (cod2 -> SHIFT .)


state 6

    (9) expression -> cod4 . [ NUMBER ]

    [               shift and go to state 14


state 7

    (5) expression -> cod2 . R NUMBER NUMBER

    R               shift and go to state 15


state 8

    (4) cod1 -> STORE .

    R               reduce using rule 4 (cod1 -> STORE .)


state 9

    (0) S' -> statement .



state 10

    (2) expression -> cod1 . R NUMBER [ NUMBER ]

    R               shift and go to state 16


state 11

    (12) cod4 -> BEQ .

    [               reduce using rule 12 (cod4 -> BEQ .)


state 12

    (1) statement -> expression .

    $end            reduce using rule 1 (statement -> expression .)


state 13

    (8) expression -> STOREI . NUMBER [ NUMBER ]

    NUMBER          shift and go to state 17


state 14

    (9) expression -> cod4 [ . NUMBER ]

    NUMBER          shift and go to state 18


state 15

    (5) expression -> cod2 R . NUMBER NUMBER

    NUMBER          shift and go to state 19


state 16

    (2) expression -> cod1 R . NUMBER [ NUMBER ]

    NUMBER          shift and go to state 20


state 17

    (8) expression -> STOREI NUMBER . [ NUMBER ]

    [               shift and go to state 21


state 18

    (9) expression -> cod4 [ NUMBER . ]

    ]               shift and go to state 22


state 19

    (5) expression -> cod2 R NUMBER . NUMBER

    NUMBER          shift and go to state 23


state 20

    (2) expression -> cod1 R NUMBER . [ NUMBER ]

    [               shift and go to state 24


state 21

    (8) expression -> STOREI NUMBER [ . NUMBER ]

    NUMBER          shift and go to state 25


state 22

    (9) expression -> cod4 [ NUMBER ] .

    $end            reduce using rule 9 (expression -> cod4 [ NUMBER ] .)


state 23

    (5) expression -> cod2 R NUMBER NUMBER .

    $end            reduce using rule 5 (expression -> cod2 R NUMBER NUMBER .)


state 24

    (2) expression -> cod1 R NUMBER [ . NUMBER ]

    NUMBER          shift and go to state 26


state 25

    (8) expression -> STOREI NUMBER [ NUMBER . ]

    ]               shift and go to state 27


state 26

    (2) expression -> cod1 R NUMBER [ NUMBER . ]

    ]               shift and go to state 28


state 27

    (8) expression -> STOREI NUMBER [ NUMBER ] .

    $end            reduce using rule 8 (expression -> STOREI NUMBER [ NUMBER ] .)


state 28

    (2) expression -> cod1 R NUMBER [ NUMBER ] .

    $end            reduce using rule 2 (expression -> cod1 R NUMBER [ NUMBER ] .)

